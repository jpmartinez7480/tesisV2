getQuantileHigh <- function(signal){
  high_data<-(-quantile(-signal, .01,na.rm = TRUE))
  return (ifelse(is.na(high_data),numeric(0), high_data))
}

getQuantileLow <- function(signal){
  low_data<-(quantile(signal, .01,na.rm = TRUE))
  return (ifelse(is.na(low_data),numeric(0), low_data))
}

getOutliers <- function(signal,vh, vl){
  posOutliers<-sort(union(which(signal<=vl),which(signal>=vh)))
  cantidadOutliers<-length(posOutliers)
  #Si el valor del ultimo elemento coincide con la cantidad de samples, se quita pues es motivo de error
  #if (posOutliers[cantidadOutliers]==length(signal)){
  #  length(posOutliers) <- length(posOutliers)-1
  #}
  if (length(posOutliers)==0){
    return (signal)
  }
  else
    return(posOutliers)
}

getSpline <- function(signal,posOutliers){
  library(zoo)
  splineSignal <- NULL
  listaSNA <- vector()
  tryCatch(
    expr = {
      splineSignal<-pracma::interp1(signal[-posOutliers],
                                   signal[-posOutliers],
                                   signal,method = "spline")
      return (splineSignal)
    },
    error=function(e) {
      listaSNA<-signal
      listaSNA[posOutliers]<-NA
      #listaSNA<-zoo::zoo(listaSNA,signal)
      listaSNA<-zoo::na.approx(listaSNA, rule = 2)
      return (listaSNA)
    }
  )
}

getHermiteSplineInterpolation <- function(signal){
  library(jsonlite)
  cnt <- 0
  can_do_spline <- FALSE
  can_get_outliers <- FALSE
  can_get_quantile_low <- FALSE
  can_get_quantile_high <- TRUE
  #result <- fromJSON(signal, simplifyVector = TRUE)
  #signal <- as.data.frame(result)
  signal <- fromJSON(signal, simplifyVector = TRUE)
  signal_filtered <- c()
  final <- list()
  res_ql <- 0
  res_qh <- 0
  aux_qh <- 0
  res_outliers <- 0
  j <- 1
  i <- 1
  while(cnt < 8){
    if(can_do_spline){
      signal_filtered <- NULL
      if(typeof(res_outliers) == 'integer'){
        result <- c(getSpline(signal[i-3,], res_outliers))
        final[j] <- list(result)
        j <- j + 1
      }
      else{
        final[j] <- res_outliers
        j <- j + 1
      }
    }
    if(can_get_outliers){
      res_outliers <- getOutliers(signal[i-2,], aux_qh, res_ql)
      can_do_spline <- TRUE
    }
    if(can_get_quantile_low){
      res_ql <- getQuantileLow(signal[i-1,])
      aux_qh <- res_qh
      can_get_outliers <- TRUE
    }
    if(can_get_quantile_high){
      res_qh <- getQuantileHigh(signal[i,])
      can_get_quantile_low <- TRUE
    }
    if( i < 7){
      i <- i + 1
    }
    if(i == 5){
      can_get_quantile_high <- FALSE
    }
    if(i == 6){
      can_get_quantile_low <- FALSE
    }
    if(i == 7){
      can_get_outliers <- FALSE
    }
    cnt <- cnt + 1
  }
  return (final)
}


SplineFilter <- function(signal){
  library(jsonlite)
  final <- list()
  cnt <- 0
  signal <- fromJSON(signal, simplifyVector = TRUE)
  while(cnt < 4){
    qh <- getQuantileHigh(signal[cnt,])
    ql <- getQuantileLow(signal[cnt,])
    outlier <- getOutliers(signal[cnt,],qh,ql)
    result <- list(getSpline(signal[cnt,],outlier))
    final[cnt] <- result
    cnt <- cnt + 1
  }
  return(final)
}


filtradoSpline3<-function(listaSenal,stringNombreColumnaAFiltrar,stringNombreColumnaSample){
  library("jsonlite")
  library("zoo")
  #toJSON(setNames(listaSeñal, NULL))
  #Se obtienen las posiciones de ...
  #1 porciento dato mas alto de la señal
  listaSenal <- '[{
  "V1": "11:26:37:21",
  "V2": "0",
  "V3": 31,
  "V4": 38,
  "V5": 57.81,
  "V6": 7.6,
  "V7": "27.6",
  "V8": "0",
  "V9": "6.642",
  "V10": "25",
  "V11": "6.888",
  "V12": "6.888"
},
  {
  "V1": "11:26:37:22",
  "V2": "1",
  "V3": 30,
  "V4": 37,
  "V5": 57.564,
  "V6": 8.2,
  "V7": "27.6",
  "V8": "0",
  "V9": "6.642",
  "V10": "25",
  "V11": "6.888",
  "V12": "6.888"
  },
  {
  "V1": "11:26:37:23",
  "V2": "2",
  "V3": 29,
  "V4": 40,
  "V5":57.81,
  "V6": 8.2,
  "V7": "27.6",
  "V8": "0",
  "V9": "6.642",
  "V10": "25",
  "V11": "6.888",
  "V12": "6.888"
  },
  {
  "V1": "11:26:37:24",
  "V2": "3",
  "V3": 27,
  "V4": 31,
  "V5": 57.564,
  "V6": 8.2,
  "V7": "27.6",
  "V8": "0",
  "V9": "6.642",
  "V10": "25",
  "V11": "6.888",
  "V12": "6.888"
  },
  {
  "V1": "11:26:37:25",
  "V2": "4",
  "V3": 19,
  "V4": 30,
  "V5": 57.072,
  "V6": 8.2,
  "V7": "27.4",
  "V8": "0",
  "V9": "6.642",
  "V10": "25",
  "V11": "6.888",
  "V12": "6.888"
  }
  ]'
  result <- fromJSON(listaSenal, simplifyVector = TRUE)
  listaSenal <- as.data.frame(result)
  datoAltos<-(-quantile(-as.numeric(unlist(listaSenal["V6"])), .01,na.rm = TRUE))
  datoAltos<-ifelse(is.na(datoAltos),numeric(0), datoAltos)
  #1 porciento dato mas bajo de la señal
  datoBajos<-quantile(as.numeric(unlist(listaSenal["V6"])), .01,na.rm = TRUE)
  datoBajos<-ifelse(is.na(datoBajos),numeric(0), datoBajos)
  posOutliers<-sort(union(which(as.numeric(unlist(listaSenal[,"V6"]))<=datoBajos),which(as.numeric(unlist(listaSenal[,"V6"]))>=datoAltos)))

  #posOutliers<-posOutliers[-(which(posOutliers>=length(listaSeñal[,stringNombreColumnaSample])))]
  cantidadOutliers<-length(posOutliers)
  #largoSeñal<-length(listaSeñal[,stringNombreColumnaSample])

  #Si el valor del ultimo elemento coincide con la cantidad de samples, se quita pues es motivo de error
  if (posOutliers[cantidadOutliers]==length(listaSenal[,"V6"])){
    length(posOutliers) <- length(posOutliers)-1
  }

  if (length(posOutliers)==0){
    return (listaSenal[,"V6"])
  }
  #Preprocesado con Spline, para eliminar los valores antes señalados
  señalSpline<-NULL

  tryCatch(
    expr = {
      señalSpline<-pracma::interp1(as.numeric(unlist(listaSenal[-posOutliers,stringNombreColumnaSample])),
                                   as.numeric(unlist(listaSenal[-posOutliers,"V6"])),
                                   as.numeric(unlist(listaSenal[,stringNombreColumnaSample])),method = "spline")
      return (señalSpline)
    },
    error=function(e) {
      #print (paste("[Precaucion] <",stringNombreArchivoSalida,"> presenta un fallo en <",stringNombreColumnaAFiltrar,"> debido a que presenta 4 o mas outliers seguidos y se ha filtrado de forma lineal.",sep=""))
      listaSNA<-as.numeric(unlist(listaSenal["V6"]))
      listaSNA[posOutliers]<-NA
      listaSNA<-zoo::zoo(listaSNA,listaSenal[,stringNombreColumnaSample])
      listaSNA<-zoo::na.approx(listaSNA, rule = 2)
      return (listaSNA)
    }
  )
  }


